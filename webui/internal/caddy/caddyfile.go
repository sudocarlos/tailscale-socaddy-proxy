package caddy

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/sudocarlos/tailrelay-webui/internal/config"
)

// GenerateCaddyfile generates a Caddyfile from proxy configurations
func GenerateCaddyfile(proxies []config.CaddyProxy, outputPath string) error {
	var sb strings.Builder

	sb.WriteString("# Generated by Tailrelay Web UI\n")
	sb.WriteString("# Do not edit manually - changes will be overwritten\n\n")

	for _, proxy := range proxies {
		if !proxy.Enabled {
			continue // Skip disabled proxies
		}

		// Site block: hostname:port
		sb.WriteString(fmt.Sprintf("%s:%d {\n", proxy.Hostname, proxy.Port))

		// Reverse proxy directive
		sb.WriteString(fmt.Sprintf("\treverse_proxy %s {\n", proxy.Target))

		// Header passthrough
		sb.WriteString("\t\theader_up Host {upstream_hostport}\n")

		// Trusted proxies if enabled
		if proxy.TrustedProxies {
			sb.WriteString("\t\ttrusted_proxies private_ranges\n")
		}

		// Custom headers
		if len(proxy.CustomHeaders) > 0 {
			for key, value := range proxy.CustomHeaders {
				sb.WriteString(fmt.Sprintf("\t\theader_up %s %s\n", key, value))
			}
		}

		// TLS configuration for HTTPS targets
		if strings.HasPrefix(proxy.Target, "https://") {
			sb.WriteString("\t\ttransport http {\n")
			sb.WriteString("\t\t\ttls_insecure_skip_verify\n")
			sb.WriteString("\t\t}\n")
		}

		sb.WriteString("\t}\n")
		sb.WriteString("}\n\n")
	}

	// Write to file
	if err := os.WriteFile(outputPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write Caddyfile: %w", err)
	}

	return nil
}

// LoadProxies loads proxy configurations from JSON file
func LoadProxies(filePath string) ([]config.CaddyProxy, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			// Return empty list if file doesn't exist
			return []config.CaddyProxy{}, nil
		}
		return nil, fmt.Errorf("failed to read proxies file: %w", err)
	}

	var proxyList config.CaddyProxyList
	if err := json.Unmarshal(data, &proxyList); err != nil {
		return nil, fmt.Errorf("failed to parse proxies file: %w", err)
	}

	return proxyList.Proxies, nil
}

// SaveProxies saves proxy configurations to JSON file
func SaveProxies(filePath string, proxies []config.CaddyProxy) error {
	proxyList := config.CaddyProxyList{
		Proxies: proxies,
	}

	data, err := json.MarshalIndent(proxyList, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal proxies: %w", err)
	}

	if err := os.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write proxies file: %w", err)
	}

	return nil
}

// AddProxy adds a new proxy to the list
func AddProxy(filePath string, proxy config.CaddyProxy) error {
	proxies, err := LoadProxies(filePath)
	if err != nil {
		return err
	}

	proxies = append(proxies, proxy)

	return SaveProxies(filePath, proxies)
}

// UpdateProxy updates an existing proxy by ID
func UpdateProxy(filePath string, updatedProxy config.CaddyProxy) error {
	proxies, err := LoadProxies(filePath)
	if err != nil {
		return err
	}

	found := false
	for i, proxy := range proxies {
		if proxy.ID == updatedProxy.ID {
			proxies[i] = updatedProxy
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("proxy with ID %s not found", updatedProxy.ID)
	}

	return SaveProxies(filePath, proxies)
}

// DeleteProxy removes a proxy by ID
func DeleteProxy(filePath string, proxyID string) error {
	proxies, err := LoadProxies(filePath)
	if err != nil {
		return err
	}

	newProxies := []config.CaddyProxy{}
	found := false
	for _, proxy := range proxies {
		if proxy.ID != proxyID {
			newProxies = append(newProxies, proxy)
		} else {
			found = true
		}
	}

	if !found {
		return fmt.Errorf("proxy with ID %s not found", proxyID)
	}

	return SaveProxies(filePath, newProxies)
}

// ToggleProxy enables or disables a proxy by ID
func ToggleProxy(filePath string, proxyID string, enabled bool) error {
	proxies, err := LoadProxies(filePath)
	if err != nil {
		return err
	}

	found := false
	for i, proxy := range proxies {
		if proxy.ID == proxyID {
			proxies[i].Enabled = enabled
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("proxy with ID %s not found", proxyID)
	}

	return SaveProxies(filePath, proxies)
}

// GetProxy retrieves a single proxy by ID
func GetProxy(filePath string, proxyID string) (*config.CaddyProxy, error) {
	proxies, err := LoadProxies(filePath)
	if err != nil {
		return nil, err
	}

	for _, proxy := range proxies {
		if proxy.ID == proxyID {
			return &proxy, nil
		}
	}

	return nil, fmt.Errorf("proxy with ID %s not found", proxyID)
}
